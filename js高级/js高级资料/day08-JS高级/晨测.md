### 12.17
- 检测数据类型的方法
    判断数据类型：

        typeof能够检测出来的类型：
                number、boolean、string、undefined、function、symbol(ES6)、bigint(ES6)

        
        ===:
            null和undefined只有一个唯一的值 所以可以使用全等判断 null和undefined

        A instanceof B:
            判断B在不在A的原型链上 只要在就都会返回true

        Object.prototype.toString.call(任意类型).slice(8,-1).toLowerCase():    
            完美的检测任意数据类型

- 说明变量类型和数据类型
            
            变量类型：
                基本类型
                引用类型
                
            数据类型：
                基本类型值
                对象类型值

- 分析点操作符和中括号操作符
    对象的key 最终解析出来一定是一个字符串类型，不可能是其他类型
            
    .操作符:叫做成员访问，访问或者设置一个对象的属性或方法，但是点操作符后跟的都是字符串

    []操作符对于对象来说：访问或者设置一个对象的属性或方法，中括号中可以书写变量（最终会把变量解析为字符串），也可以书写字符串，但是必须添加引号

    []操作符是万能的，里边可以书写变量或字符串，但是点操作符只能书写字符串（不用添加引号）

    使用[]的场景：1.属性是用变量来表示的  2.key命名不规范 需要添加引号
        
- 什么是回调函数
    1.函数是你定义的
    2.你没有调用这个函数
    3.这个函数执行了


- 谈一谈this
    this是什么？
        - 一个关键字，一个引用变量
        - this在函数中可以直接使用
        - this指向其所在函数的调用者，如果没有则指向window
        - this在函数执行的时候才确定指向

    this的指向和函数的调用方式相关：
        - 函数默认调用（独立函数调用）
            - 指向window
        - 上下文对象调用
            - 指向上下文对象
            - 可能会出现隐式丢失现象（注意隐式丢失以后，this的指向）
        - 实例化调用
            - this指向实例化对象

        - call apply bind 强制绑定
            指向call、apply、bind的第一个参数


- 谈一谈call、apply、bind
    call,apply,bind是Function对象原型对象上自带的三个方法，所有的函数都能调用

    - 改变函数执行时的上下文，或者改变函数调用时的this指向

    call方法：
        - 执行调用call方法的函数
        - 改变调用call方法的函数中的this指向 指向call方法的第一个参数

    call方法参数
        1.this被改变的指向的对象
            - 如果第一个参数是 null或者undefined  则改变this指向window
            - 如果是基本包装类型，指向其的包装对象
            - 如果是对象类型，则直接指向当前对象
        2.后边的参数都是 被调用函数的实参  逗号间隔开

    apply:
        apply和call基本一样
        但是传参的时候有些同
            - call给函数传参的时候，是作为call的第二个参数以后所有的参数 逗号隔开
            - apply 给函数传参的时候，函数的参数全部放在数组中，作为apply的第二个参数
    
    bind:   
        和call的功能基本类似，传参方式也一样
        区别：
            call和apply作用是改变this指向，并直接调用函数
            bind作用是改变this指向，并返回一个改变this指向以后的函数（不会调用）
        
        
